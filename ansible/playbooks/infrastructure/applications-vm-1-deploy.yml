---
- name: "Applications VM 1: Create Debian VM with Docker and Portainer"
  hosts: privatebox-proxmox
  gather_facts: true

  environment:
    ANSIBLE_JINJA2_NATIVE: "True"

  vars:
    # VM configuration
    vmid: 102
    vm_name: "applications-vm"
    vm_memory: 2048
    vm_cores: 2
    vm_disk_size: "15G"
    vm_storage: "local-lvm"

    # Network configuration - Services VLAN only
    services_ip: "10.10.20.30"
    services_netmask: "24"
    services_gateway: "10.10.20.1"

    # Debian cloud image (same as other VMs)
    debian_version: "13"
    debian_image_url: "https://cloud.debian.org/images/cloud/trixie/latest/debian-13-genericcloud-amd64.qcow2"
    debian_image_name: "debian-13-genericcloud-amd64.qcow2"
    image_cache_dir: "/var/lib/vz/template/cache"

    # Semaphore configuration
    semaphore_url: "https://10.10.20.10:2443"
    project_id: 1

    # Template configuration for Semaphore
    template_config:
      semaphore_environment: "privatebox-env-passwords"
      semaphore_inventory: "privatebox-proxmox"
      semaphore_survey_vars: []  # No variables needed - fully automated

  tasks:
    - name: Display deployment header
      debug:
        msg:
          - "=========================================="
          - "   APPLICATIONS VM CREATION"
          - "=========================================="
          - "VMID: {{ vmid }}"
          - "Services IP: {{ services_ip }}"
          - "Container Runtime: Docker + Portainer"

    # Pre-flight checks
    - name: Check if VM already exists
      command: qm status {{ vmid }}
      register: vm_exists
      failed_when: false
      changed_when: false

    - name: Fail if VM already exists
      fail:
        msg: "VM {{ vmid }} already exists. Delete it first or choose a different VMID."
      when: vm_exists.rc == 0

    - name: Create image cache directory
      file:
        path: "{{ image_cache_dir }}"
        state: directory
        mode: '0755'

    # Download Debian cloud image
    - name: Check if Debian image exists
      stat:
        path: "{{ image_cache_dir }}/{{ debian_image_name }}"
      register: debian_image_stat

    - name: Download Debian cloud image
      get_url:
        url: "{{ debian_image_url }}"
        dest: "{{ image_cache_dir }}/{{ debian_image_name }}"
        mode: '0644'
      when: not debian_image_stat.stat.exists

    # Create cloud-init configuration
    - name: Enable snippets on local storage
      command: pvesm set local --content vztmpl,iso,backup,snippets
      failed_when: false
      changed_when: false

    - name: Create snippets directory
      file:
        path: /var/lib/vz/snippets
        state: directory
        mode: '0755'

    - name: Read PrivateBox CA certificate from Proxmox
      slurp:
        src: /etc/privatebox/certs/privatebox.crt
      register: privatebox_ca_cert

    - name: Read PrivateBox CA private key from Proxmox
      slurp:
        src: /etc/privatebox/certs/privatebox.key
      register: privatebox_ca_key

    - name: Generate cloud-init user-data
      copy:
        dest: "/var/lib/vz/snippets/applications-vm-{{ vmid }}.yml"
        mode: '0644'
        content: |
          #cloud-config
          hostname: {{ vm_name }}
          manage_etc_hosts: true

          users:
            - name: debian
              sudo: ALL=(ALL) NOPASSWD:ALL
              shell: /bin/bash
              lock_passwd: false
              plain_text_passwd: {{ ADMIN_PASSWORD }}

          ssh_pwauth: true

          package_update: true
          package_upgrade: true

          packages:
            - curl
            - ca-certificates
            - gnupg
            - apt-transport-https

          write_files:
            - path: /etc/resolv.conf
              permissions: '0644'
              content: |
                nameserver 10.10.20.10

            - path: /usr/local/share/ca-certificates/privatebox.crt
              permissions: '0644'
              encoding: b64
              content: {{ privatebox_ca_cert.content }}

            - path: /etc/privatebox/certs/privatebox.crt
              permissions: '0644'
              encoding: b64
              content: {{ privatebox_ca_cert.content }}

            - path: /etc/privatebox/certs/privatebox.key
              permissions: '0600'
              encoding: b64
              content: {{ privatebox_ca_key.content }}

          runcmd:
            # Install PrivateBox CA certificate
            - mkdir -p /etc/privatebox/certs
            - update-ca-certificates
            # Wait for network and DNS
            - timeout 30 sh -c 'until ping -c1 8.8.8.8 >/dev/null 2>&1; do sleep 1; done'
            # Install Docker
            - install -m 0755 -d /etc/apt/keyrings
            - curl -fsSL https://download.docker.com/linux/debian/gpg -o /etc/apt/keyrings/docker.asc
            - chmod a+r /etc/apt/keyrings/docker.asc
            - echo "deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.asc] https://download.docker.com/linux/debian $(. /etc/os-release && echo "$VERSION_CODENAME") stable" | tee /etc/apt/sources.list.d/docker.list > /dev/null
            - apt-get update
            - apt-get install -y docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin
            # Add debian user to docker group
            - usermod -aG docker debian
            # Enable and start Docker
            - systemctl enable docker
            - systemctl start docker
            # Deploy Portainer
            - docker volume create portainer_data
            - docker run -d -p 8000:8000 -p 9443:9443 --name portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data -v /etc/privatebox/certs/privatebox.crt:/certs/cert.pem:ro -v /etc/privatebox/certs/privatebox.key:/certs/key.pem:ro portainer/portainer-ce:latest --sslcert /certs/cert.pem --sslkey /certs/key.pem
            # Wait for Portainer to start
            - timeout 60 sh -c 'until curl -k https://localhost:9443/api/system/status >/dev/null 2>&1; do sleep 2; done'
            # Initialize Portainer admin user
            - 'curl -k -X POST https://localhost:9443/api/users/admin/init -H "Content-Type: application/json" -d "{\"Username\":\"admin\",\"Password\":\"{{ SERVICES_PASSWORD }}\"}" || true'
            # Generate SSH key for Ansible access
            - mkdir -p /home/debian/.ssh
            - ssh-keygen -t ed25519 -f /home/debian/.ssh/id_ed25519 -N '' -C 'applications-vm@privatebox'
            - cat /home/debian/.ssh/id_ed25519.pub >> /home/debian/.ssh/authorized_keys
            - chmod 700 /home/debian/.ssh
            - chmod 600 /home/debian/.ssh/authorized_keys /home/debian/.ssh/id_ed25519
            - chown -R debian:debian /home/debian/.ssh
            - echo "Applications VM ready"

          final_message: "Applications VM deployed after $UPTIME seconds"

    # Create VM
    - name: Create VM {{ vmid }}
      command: >
        qm create {{ vmid }}
        --name {{ vm_name }}
        --memory {{ vm_memory }}
        --cores {{ vm_cores }}
        --cpu host
        --net0 virtio,bridge=vmbr1,tag=20
        --serial0 socket
        --vga serial0
        --agent enabled=1
        --onboot 1
      register: vm_created

    - name: Import disk image
      command: qm importdisk {{ vmid }} {{ image_cache_dir }}/{{ debian_image_name }} {{ vm_storage }}
      when: vm_created is succeeded

    - name: Attach and configure disk
      command: >
        qm set {{ vmid }}
        --scsihw virtio-scsi-pci
        --scsi0 {{ vm_storage }}:vm-{{ vmid }}-disk-0
        --boot c
        --bootdisk scsi0
      when: vm_created is succeeded

    - name: Resize disk
      command: qm resize {{ vmid }} scsi0 {{ vm_disk_size }}
      when: vm_created is succeeded

    - name: Add cloud-init drive
      command: qm set {{ vmid }} --ide2 {{ vm_storage }}:cloudinit
      when: vm_created is succeeded

    - name: Configure cloud-init network
      command: >
        qm set {{ vmid }}
        --ipconfig0 ip={{ services_ip }}/{{ services_netmask }},gw={{ services_gateway }}
        --nameserver 10.10.20.10
        --cicustom "user=local:snippets/applications-vm-{{ vmid }}.yml"
      when: vm_created is succeeded

    - name: Start VM
      command: qm start {{ vmid }}
      when: vm_created is succeeded

    - name: Wait for VM to be running
      command: qm status {{ vmid }}
      register: vm_status
      until: vm_status.stdout.find('running') != -1
      retries: 30
      delay: 2

    - name: Wait for SSH to be available on Services IP
      wait_for:
        host: "{{ services_ip }}"
        port: 22
        delay: 10
        timeout: 180

    - name: Wait for cloud-init to complete
      command: >
        sshpass -p {{ ADMIN_PASSWORD }} ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null debian@{{ services_ip }}
        "cloud-init status --wait"
      register: cloudinit_wait
      changed_when: false
      timeout: 300

    - name: Verify cloud-init status
      command: >
        sshpass -p {{ ADMIN_PASSWORD }} ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null debian@{{ services_ip }}
        "cloud-init status --long"
      register: cloudinit_status
      changed_when: false

    - name: Verify Docker and Portainer installation
      command: >
        sshpass -p {{ ADMIN_PASSWORD }} ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null debian@{{ services_ip }}
        "docker --version && docker ps --filter 'name=portainer'"
      register: docker_check
      changed_when: false

    - name: Display cloud-init result
      debug:
        msg:
          - "✓ Cloud-init completed"
          - "✓ Docker installed"
          - "✓ Docker version: {{ docker_check.stdout_lines[0] }}"
          - "✓ Portainer: {{ docker_check.stdout_lines[1] if docker_check.stdout_lines | length > 1 else 'Running' }}"
          - "✓ SSH key generated"

    - name: Retrieve private key from applications VM
      command: sshpass -p {{ ADMIN_PASSWORD }} ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null debian@{{ services_ip }} "cat /home/debian/.ssh/id_ed25519"
      register: private_key_content
      changed_when: false

    - name: Retrieve public key from applications VM
      command: sshpass -p {{ ADMIN_PASSWORD }} ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null debian@{{ services_ip }} "cat /home/debian/.ssh/id_ed25519.pub"
      register: public_key_content
      changed_when: false

    - name: Save private key to temporary file
      copy:
        content: "{{ private_key_content.stdout }}"
        dest: "/tmp/applications-vm-{{ vmid }}-private-key"
        mode: '0600'

    - name: Read private key from file
      slurp:
        src: "/tmp/applications-vm-{{ vmid }}-private-key"
      register: private_key_file

    # Register SSH key in Semaphore
    - name: Check if SSH key already exists in Semaphore
      uri:
        url: "{{ semaphore_url }}/api/project/{{ project_id }}/keys"
        method: GET
        headers:
          Authorization: "Bearer {{ SEMAPHORE_API_TOKEN }}"
        validate_certs: no
        status_code: [200]
      register: existing_keys

    - name: Parse existing key ID
      set_fact:
        existing_key_id: "{{ (existing_keys.json | selectattr('name', 'equalto', 'applications-vm') | first).id | default(0) }}"

    - name: Register SSH key in Semaphore (using jq for proper JSON types)
      shell: |
        jq -n \
          --arg name "applications-vm" \
          --arg type "ssh" \
          --argjson pid {{ project_id }} \
          --arg key "{{ private_key_file.content | b64decode }}" \
          '{name: $name, type: $type, project_id: $pid, ssh: {private_key: $key}}' | \
        curl -ksS -f \
          -H "Authorization: Bearer {{ SEMAPHORE_API_TOKEN }}" \
          -H "Content-Type: application/json" \
          -d @- \
          "{{ semaphore_url }}/api/project/{{ project_id }}/keys"
      register: ssh_key_response
      when: existing_key_id | int == 0
      changed_when: true

    - name: Set SSH key ID
      set_fact:
        ssh_key_id: "{{ ((ssh_key_response.stdout | from_json).id if existing_key_id | int == 0 else existing_key_id) | int }}"

    # Create inventory in Semaphore
    - name: Check if inventory already exists
      uri:
        url: "{{ semaphore_url }}/api/project/{{ project_id }}/inventory"
        method: GET
        headers:
          Authorization: "Bearer {{ SEMAPHORE_API_TOKEN }}"
        validate_certs: no
        status_code: [200]
      register: existing_inventories

    - name: Parse existing inventory ID
      set_fact:
        existing_inventory_id: "{{ (existing_inventories.json | selectattr('name', 'equalto', 'applications-vm') | first).id | default(0) }}"

    - name: Build inventory YAML
      set_fact:
        inventory_yaml: |
          all:
            hosts:
              applications-vm:
                ansible_host: {{ services_ip }}
                ansible_user: debian

    - name: Create applications inventory in Semaphore (using jq for proper JSON types)
      shell: |
        jq -n \
          --arg name "applications-vm" \
          --arg type "static" \
          --argjson pid {{ project_id }} \
          --arg inv "{{ inventory_yaml }}" \
          --argjson keyid {{ ssh_key_id }} \
          '{name: $name, type: $type, project_id: $pid, inventory: $inv, ssh_key_id: $keyid}' | \
        curl -ksS -f \
          -H "Authorization: Bearer {{ SEMAPHORE_API_TOKEN }}" \
          -H "Content-Type: application/json" \
          -d @- \
          "{{ semaphore_url }}/api/project/{{ project_id }}/inventory"
      register: inventory_response
      when: existing_inventory_id | int == 0
      changed_when: true

    - name: Remove temporary private key file
      file:
        path: "/tmp/applications-vm-{{ vmid }}-private-key"
        state: absent

    - name: Display deployment summary
      debug:
        msg:
          - ""
          - "=========================================="
          - "   APPLICATIONS VM DEPLOYMENT COMPLETE"
          - "=========================================="
          - ""
          - "VM Details:"
          - "  VM ID: {{ vmid }}"
          - "  VM Name: {{ vm_name }}"
          - "  Services IP: {{ services_ip }}"
          - "  Cloud-init: Completed successfully"
          - ""
          - "Installed Services:"
          - "  Docker: {{ docker_check.stdout_lines[0] }}"
          - "  Portainer: Running on https://{{ services_ip }}:9443"
          - "  Portainer URL: https://application.lan"
          - ""
          - "Semaphore Integration:"
          - "  SSH Key: Registered as 'applications-vm'"
          - "  SSH Key ID: {{ ssh_key_id }}"
          - "  Inventory: Created as 'applications-vm'"
          - "  Public Key: {{ public_key_content.stdout }}"
          - ""
          - "Access:"
          - "  SSH: ssh debian@{{ services_ip }}"
          - "  Password: (using ADMIN_PASSWORD)"
          - "  Portainer: https://application.lan"
          - "  Portainer Admin: admin / SERVICES_PASSWORD"
          - ""
          - "Next Steps:"
          - "  1. Access Portainer at https://application.lan"
          - "  2. Deploy user containers via Portainer UI"
          - "  3. All containers accessible at {{ services_ip }}:<port>"
          - ""
